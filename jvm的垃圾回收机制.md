---
title: jvm的垃圾回收机制
date: 2021-01-13 17:03:25
tags: [算法,jvm]
categories: java虚拟机
---

垃圾回收（Garbage Collection，GC），就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。

### 一、判断对象是否需要被回收：

在强引用的情况下，**不再以任何途径被使用的对象就需要回收**，在非强引用的情况下视情况回收。在java里面，几乎所有的对象实例都是在堆上分配，所以垃圾收集器第一件事情就是要判断堆上的这些实例是不再被使用的，那些还在被使用。判断对象是否存活主要有两种算法，一种是“引用计数算法”，一种是“可达性分析算法”。

#### 1、引用计数算法

算法描述：给对象增加一个引用计数器，每当有一个地方引用它时，计数器就+1；当引用失效时，计数器就-1；任何时刻计数器为0的对象就是不能再被使用的，即对象已“死”。

引用计数法实现简单，判定效率也比较高，在大部分情况下都是一个比较好的算法。比如Python语言就是采用的引用计数法来进行内存管理的。

**在主流的JVM中没有选用引用计数法来管理内存，最主要的原因是引用计数法无法解决对象的循环引用问题**

#### 2、可达性分析算法

通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。如图所示，对象object 5、object 6、object 7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。

<img src="https://longqing9.gitee.io/blog/images/2021011301.png" style="zoom:80%;" />

在Java语言中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈中引用的对象（栈帧中的本地变量表）；

-  方法区中类静态属性引用的对象；

- 方法区中常量引用的对象；

- 本地方法栈中JNI（Native方法）引用的对象。

**可达性分析算法会不会出现对象间循环引用问题呢？答案是不会出现对象间循环引用问题**。GC Root在对象图之外，是特别定义的“起点”，不可能被对象图内的对象所引用。

在Java虚拟机进行GC时，在可达性分析算法中检测到不可达对象，也不会再第一次GC时将对象回收。真正宣告一个对象死亡至少要经理两次标记过程：如果对象在进行可达性分析后发现与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行finapze()方法，当对象没有覆盖finapze()方法，或者finapze()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。程序中可以通过覆盖finapze()来一场"惊心动魄"的自我拯救过程，但是，这只有一次机会

### 二、垃圾回收算法

在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收，但是这里面涉及到一个问题是：如何高效地进行垃圾回收。由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器，所以在此只讨论几种常见的垃圾收集算法的核心思想。

#### 1、标记清除（Mark-Sweep）算法

标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。具体过程如下图所示：

<img src="https://longqing9.gitee.io/blog/images/181024382398115.jpg" style="zoom:80%;" />

缺点：内存碎片化。导致较大的对象无法在堆上分配内存空间，这时就会在再次触发垃圾回收机制。

#### 2、复制（coping）算法

为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。具体过程如下图所示：

<img src="https://longqing9.gitee.io/blog/images/181041528488728.jpg" style="zoom:80%;" />

缺点：垃圾回收的效率与存活的对象有关，如果有大量对象存活，垃圾回收的效率会大大降低



#### 3、标记-整理（Mark-Compact）算法

为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。这样能避免复制算法带来的效率问题，同时也能避免内存碎片化的问题。老年代的垃圾回收称为“Major GC”。具体过程如下图所示：

<img src="https://longqing9.gitee.io/blog/images/181100129575916.jpg" style="zoom:80%;" />





参考：

- https://www.cnblogs.com/aspirant/p/8662690.html
- https://my.oschina.net/xiaolyuh/blog/3155629
- https://blog.csdn.net/yrwan95/article/details/82829186