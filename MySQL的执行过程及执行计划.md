---
title: MySQL的执行过程及执行计划
date: 2021-06-13 14:50:18
tags: [MySQL]
categories: MySQL
---

### 1、SQL语句的执行的过程

- 1、连接器：当客户端登录MySQL时进行身份验证和权限判断；
- 2、查询缓存：执行查询语句的时，会先查询缓存，命中则直接返回；没有则进行下一步；
- 3、分析器：没有命中缓存的情况下，SQL请求就会来到分析器，分析器负责明确SQL要完成的功能，以及检查SQL的语法是否正确；
- 4、优化器：为SQL提供优化执行方案；
- 5、执行器：将语句分发到对应的存储引擎中，并返回数据；

#### 1.1 连接器

负责当客户端登录MySQL时进行身份验证和权限判断；并进行分配连接；

##### 1.1.1 连接的状态

可用通过命令 show processlist查询连接；连接的状态如下表：

| Command        | 含义                     |
| -------------- | ------------------------ |
| sleep          | 线程正在等待客户端发数据 |
| query          | 连接线程正在执行查询     |
| locked         | 线程正在等待表锁的释放   |
| sorting result | 线程正在对结果进行排序   |
| sending data   | 向请求端返回数据         |

##### 1.1.2 长连接和短连接

MySQL将连接器中连接分为长连接和短连接：

- 长连接是指连接成功后，客户端请求一直使用是同一个连接。
- 短连接是指每次执行完SQL请求的操作之后会断开连接，如果再有SQL请求会重新建立连接。

由于短连接会反复创建连接消耗公共资源，因此多数情况下会选择长连接。但是为了保持长连接，会占用系统内存，而这些被占用的内存直到连接断开以后才会释放，解决方法如下：

- 定期断开长连接，每隔一段时间或者执行一个占用内存的大查询以后断开连接，从而释放内存，当查询的时候再重新创建连接。
- MySQL 5.7 或者更高的版本，通过执行 mysql_reset_connection 来重新初始化连接。此过程不会重新建立连接，但是会释放占用的内存，将连接恢复到刚刚创立连接的状态

#### 1.2 缓存查询

MySQL查询时会缓存查询返回的完整结构，当查询命中缓存时，MySQL会立刻返回结果，跳过解析、优化和执行阶段。查询缓存系统会跟踪查询中涉及的每一张表，如果涉及的表发生变化，那么和该表有关的缓存都将失效。MySQL将缓存存放在一个引用表中，通过哈希值引用，这个哈希值包括了以下信息：查询本身、查询的数据库、客户端协议版本等。

##### 1.2.1 影响缓存命中的因素

MySQL不会进行解析查询语句，而是直接将客户短发送来的信息和缓存中的信息进行比较。

因此空格、注解等信息的变化都会导致查询不到缓存。

##### 1.2.2 SQL结果不会被缓存的情况

- 当查询语句中包含一些不确定的数据时，则不会被缓存。例如now()或CURRENT_DATE()的查询不会被缓存的。
- 包含任何用户自定义函数，存储函数，用户变量，临时表，mysql数据库中的系统表或者包含任何列级别权限的表，都不会被缓存。

##### 1.2.3 补充

MySQL查询不建议使用缓存，因为会出现以下场景：如果正对某张表进行更新，针对这张表的查询缓存就会被清空。如果张表不断地被使用(更新、查询)，那么查询缓存会频繁地失效，获取查询缓存也失去了意义。不过可以运用在一些修改不频繁的数据表。

缓存的淘汰策略是先进先出，适用于查询远大于修改的情况下， 否则建议使用Redis或者其他做缓存工具。因此大多数情况下不推荐使用查询缓存。MySQL 8.0 版本后删除了查询缓存的功能，官方认为该功能应用场景较少，所以将其删除。

#### 1.3 分析器

如果查询没有命中缓存，SQL请求就会进入分析器。在分析器内主要分为两步：

- 词法分析：首先从SQL中图区关键字,比如，select、查询的表、查询的字段名、查询条件等；
- 语法分析：根据词法分析的结果，判断SQL语句是否正确；

词法分析程序将整个查询语句分解成各类标志，语法分析根据定义的系统语言将“各类标志”转为对MySQL有意义的组合。最后系统生成一个语法树(AST)，语法树便是优化器依赖的数据结构。

#### 1.4 优化器

查询优化器会将优化器预处理之后的语法树转化为执行计划，一条查询可以有多种执行方法，最后均会返回相同结果。查询优化器的作用就是找到这其中最好的执行计划。生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时。

如果在一条SQL语句执行的过程中将该语句对应的最终执行计划进行缓存，当相似的语句再次被输入服务器时，就可以直接使用已缓存的执行计划，从而跳过SQL语句生成执行计划的整个过程，进而可以提高语句的执行速度。 通常所讲的优化SQL，其实就是想让查询优化器，按照我们的思路,帮我们选择最优的执行方案。

MySQL在选择执行计划时，会依据成本最小原则选择使用对应的索引，成本主要是指IO成本和CPU成本：

**IO 成本**: 即从磁盘把数据加载到内存的成本，默认情况下，读取数据页的 IO 成本是 1，MySQL 是以页的形式读取数据的，即当用到某个数据时，并不会只读取这个数据，而会把这个数据相邻的数据也一起读到内存中，这就是有名的程序局部性原理，所以 MySQL 每次会读取一整页，一页的成本就是 1。所以 IO 的成本主要和页的大小有关。

**CPU 成本**：将数据读入内存后，还要检测数据是否满足条件和排序等 CPU 操作的成本，显然它与行数有关，默认情况下，检测记录的成本是 0.2。

#### 1.5 执行器

当经过优化器后,就到了执行器执行sql了. 在前面连接器处已经读取到当前用户的权限了, 连接器中只是获取到权限,并没有对权限进行判断和效验.

所以在执行器中, 在执行语句之前会判断权限, 如果没有对应的权限则会直接返回并提示没有相关权限。

### 2、MySQL的执行计划--explain

使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MYSQL是如何处理SQL语句的，分析查询语句或是表结构的性能瓶颈；

#### 2.1 执行计划的作用

- 获取表的读取速度；
- 数据读取操作的操作类型；
- 哪些索引可以使用；
- 哪些索引被实际使用；
- 表之间的引用；
- 每张表有多少行被优化器查询；

#### 2.2 explain的字段说明

id、select_type  、table、type、possible_keys、key、key_len、ref、rows、Extra

| id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
| ---- | ----------- | ----- | ---- | ------------- | ---- | ------- | ---- | ---- | ----- |
|      |             |       |      |               |      |         |      |      |       |

##### 2.2.1 字段id

- id相同：执行顺序由上到下；
- id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行；
- id相同不同同时存在：id如果相同，可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行；

##### 2.2.2 字段select_type

- SIMPLE:简单的select查询，查询中不包含子查询或union；
- PRIMARY:查询中如包含任何复杂的子部分，最外层查询则被标记为PRIMARY;
- SUBQUERY:在select或WHERE列表中包含了子查询；
- DERIVED:在from列表中包含的子查询被标记为DERIVED（衍生），MYSQL会递归执行这些子查询，把结果放在临时表中；
- UNION:若第二个select出现在union之后，则被标记为union；若UNION包含在from子句的子查询中，外层select将被标记为DERIVED；
- UNION RESULT:从UNION表获取结果的SELECT

##### 2.2.3 字段 table

table:显示这一行的数据是关于哪张表的；

##### 2.2.4 字段 type

type: 从好到坏依次是：system>const>eq_ref>ref>range>index>all;一般情况下到达range

type的各种值说明：

- system:表只有一行记录(等于系统表),这个是const类型的特例,平时不会出现,可以忽略；
- const：表示通过索引一次就找到了，const用语比较primary key或者unique索引，因为只匹配一行数据，所以很快，如将主键至于where列表中，MySQL就能将该查询转化为一个常量；
- eq_ref:唯一性索引扫描，对于每一个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描；
- ref：非唯一性索引扫描，返回匹配某个单独值的行，本质上也是一种索引访问，他返回所有匹配某个单独值的行，但是他可能找到多个符合条件的行，所以它应该属于查找和扫描的混合体；
- range:只检索给定范围的行，使用一个索引来选择行，key列显示使用了哪个索引一般就是在你的where语句中出现了between、<、>、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引；
- index：Full index scan，index与All区别为index类型只遍历索引树，这通常比ALL快，因为索引文件通常比数据文件小（也就是说虽然All和index都是读取全表，但是index是从索引中读取的，而All是从硬盘中读取的）；
- ALL：全表扫描，将遍历全表以找到匹配的行；

##### 2.2.5  字段 possible_keys

显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用；

##### 2.2.6 字段 key

际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引仅出现在key列表中；

##### 2.2.7 字段 key_len

表示索引中使用的字节数，可通过该列计算查询中使用的索引长度，在不损失精确度的情况下，长度越短越好，key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的；

##### 2.2.8 字段 ref

显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值；

##### 2.2.9 字段 rows

rows:根据表统计信息及索引选用的情况，大致估算出找到所需的记录所需要读取的行数；

##### 2.2.10 字段 Extra

包含不适合在其他列中显示但十分重要的额外信息,有以下几种情况：

- Using filesort:说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作成为“文件排序”;
- Using temporary:使用临时表保存中间结果，MySQL在对查询结果排序时使用临时表，常见于排序order by和分组查询group by;
- Using index:表示相应的select操作中使用了覆盖索引（Covering Index）避免访问了表的数据行；如果同时出现using where 表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作；
- using where：表示使用了where过滤；
- using join buffer:表明使用了 缓存；
- impossible where：表示where 子句的值总是false，不能用来获取任何元组；
- select table optimized away:在没有GroupBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化count(*)操作，不必等到执行阶段在进行计算，查询执行计划生成的阶段即完成优化；
- distinct:优化distinct操作，在找到第一个匹配的元组后即停止找同样值的动作；