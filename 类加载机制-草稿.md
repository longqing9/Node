1、对Java虚拟机来说，java与虚拟机运行的程序与编程语言无关，只与“Class文件”这种特定的二进制文件格式有关；

2、java虚拟机上运行的程序不仅仅有java程序，还有JRuby、Groovy等其他程序，这些程序经过对应语言的编译器编译为对应的class文件（Java虚拟机上运行；

3、任何一个Class文件都对应着唯一的一个类或接口的定义信息，但是类或接口并不一定都要定义在文件中，例如类或接口可以动态的生成，直接送入类加载器中。

4、Class文件是一组以8字节为基础单位的二进制流，各个数据项按照顺序紧密排列，中间无任何分隔符，如果存在超出8字节的数据，会按照高位在前的方式分割为若干个8个字节进行存储；

5、在Class文件的头4个字节被称为魔数，它的作用是确定这个文件是否为一个能被虚拟机接受的class文件。

6、一个类型从被加载到虚拟机内存开始，代卸载出内存为止，它的整个生命周期会经历加载、验证、准备、解析、初始化化、使用、卸载七个阶段，其中验证、准备、解析三部分统称为连接。

7、在《Java虚拟机规范》中严格规定了有且只有六种情况必须对类进行初始化（而加载、验证、准备自然需要在此之前开始）：

- 1、遇到new、getstatic、putstatic或invokestatic这四条指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段，能够代表这四条指令的典型Java代码场景有：
  - 使用new关键字实例化对象时；
  - 读取或设置一个类型的静态字段（被final修饰、已在编译期吧结果放入常量池的静态字段除外）
  - 调用一个类型的静态方法时；     
- 2、使用java.lang.reflect包的方法对类型进行反射调用时，如果类型没有进行过初始化，则需要先触发其初始化；
- 3、在初始化时如果其父类还没有进行初始化，则需要先触发其父类的初始化。
- 4、当虚拟机宕机时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个类。
- 5、当时用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic,REF_putStatic,REF_invokeStatic,REF_newInvokeSpecial四种类型的方法句柄，并且这个方法的句柄对应的类没有进行过初始化，需要先触发其初始化。
- 6、当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口或方法）时，如果有这个接口的实现类放生了初始化，那该接口要在其前被初始化。

8、需要注意的是，接口的加载过程和类的加载过程稍有不同，当一个类在进行初始化时，要求其父类必须在该类之前完成初始化，接口并不会要求接口的父接口必须在该接口之前完成，而是只有在真正使用到父接口的时候才会初始化。

9、类加载的过程：加载-->验证-->准备-->解析-->初始化.“加载”阶段是整个“类加载”过程中的一个阶段；

10、**加载阶段**，Java虚拟机需要完成三件事：

- 通过一个类的全限定名来获取定义此类的二进制字节流；
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在内存中生成一个代表类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

11、**验证阶段**：这一阶段的目的是为了确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被仿作代码运行后不会危害到虚拟机自身的安全。在该阶段大致上会完成四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证：

- 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，包含魔数、主次版本号、常量池等内容的验证。该阶段的验证的目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。这阶段验证的是基于二进制字节流进行的，只有通过了这阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，同时为后面三个阶段的验证都是基于方法区的存储结构上进行的，不会再去操作字节流。
- 元数据验证：该阶段的验证是对字节码描述信息进行语义分析，以保证其描述的信息符合《Java语言规范》，这个阶段的验证点有该类是否有父类、是否继承了不允许继承的类、如果该类不是抽象类，是否实现了其父类或接口中要求实现的方法等。该阶段的目的是对类的元数据进行语义校验，保证不存在与《Java语言规范》定于相冲突的元数据信息
- 字节码验证：该阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析性和控制流分析，确定程序语义是合法的、符合逻辑的，在元数据验证完成后，字节码验证就对类的方法体（Class文件中的code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。
- 符号引用验证：该阶段的校验行为发生在虚拟机将符号引用转化为值引用时，而转化的行为是在类加载的解析阶段完成的。该阶段的目的是检查该类是是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。

12、验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只要通过了验证，气候就对程序运行期没有任何影响，如果程序运行的全部代码（包含自己编写的，第三方包中的，从外部加载的、动态生成的等所有代码）都已经被反复使用过，在生产环境的实施阶段就可以考虑使用-Xverify: none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

13、**准备阶段**：该阶段是正式为类中定义变量（即静态变量、被static修饰的变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的的内存都应当在方法区中进行分配，但是需要注意的是方法区本身是一个逻辑区域，在JDK7之前HotSpot使用永久代来实现方法，完全符合这种概念，但在JDK8及之后，变量则会随着Class对象一起存放在Java堆中。

14、在准备阶段还需要注意两点：内存分配和初始值：

- 内存分配：在该阶段进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。
- 初始值：在该阶段的初始值，“通常情况”下是数据类型的零值。例如：

```java
public static int value = 123;
```

变量value在准备阶段过后的初始值为0而不是123，因为此时尚未开始执行任何Java方法，而把value赋值为123的putstatic指令时程序被编译后，存放于类构造器<clinit>()方法中，所以把value赋值为123的动作要到类的初始化阶段才会被执行。

当然在某些特殊情况下，如果类字段的字段属性存在CinstantValue属性（常量），在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值，例如：

```java
public static final int value = 123;
```

编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value设置为123.

15、**解析阶段**：该阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程

