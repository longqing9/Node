### 1、锁介绍

锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访问。InnoDB存储引擎会在行级别上对表数据上锁，但InnoDB存储引擎也会在数据库内部其他多个地方使用锁，从而允许对多种不同资源提供并发访问。数据库系统使用锁事了支持对共享资源进行并发访问，提供数据的完整性和一致性。

在MyISAM引擎，其锁是表锁设计。并发情况下的读没有问题，但是并发插入时的性能就要低一些。

### 2、lock锁和latch锁

在数据库中，lock和latch都可以被称为锁，但是两者有着截然不同的含义。

#### 2.1 lock锁

lock的对象时事务，用来锁定的是数据库中的对象，如表、页、行。通常lock锁仅在事务commit或rollback后进行释放（不同事务的隔离级别释放的时间可能不同）。

lock锁是有死锁机制的。

#### 2.2 latch锁

latch是轻量级锁，因为latch要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又可以分为mutex（互斥量）和rwlock(读写锁)其目的是用来保证并发线程操作临街资源的正确性，并且通常没有死锁检索机制。

#### 2.3 lock锁和latch锁的不同

|          | lock                                            | latch                                                        |
| -------- | ----------------------------------------------- | ------------------------------------------------------------ |
| 对象     | 事务                                            | 线程                                                         |
| 保护     | 数据库内容                                      | 内存数据结构                                                 |
| 持续时间 | 整个事务过程                                    | 临界资源                                                     |
| 模式     | 行锁、表锁、意向锁                              | 读写锁、互斥量                                               |
| 死锁     | 通过waits-for、time out等机制进行死锁检测与处理 | 无死锁检测与处理机制。仅通过应用程序加锁的顺序保证无死锁的情况发生 |
| 存在于   | Lock Manager的哈希表中                          | 每个数据结构对象中                                           |

#### 2.4 latch锁的查询

在InnoDB存储引擎中的latch，可以通过命令：

```mysql
show engine innodb mutex;
```

查询结果如下：

![](E:\Node\picture\latch1.jpg)

列Status比较复杂，在debug模式下还会有count、spin_waits、spin_rounds、os_yields、os_wait_times等信息，具体含义如下表：

| 名称          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| count         | mutex被请求的次数                                            |
| spain_waits   | spin_lock（自旋锁）的次数，InnoDB存储引擎latch在不能获得锁时首先进行自旋，若自旋后还不能获得锁，则进入等待状态； |
| spin_rounds   | 自旋内部循环的总次数，每次自旋的内部循环都是一个随机数。spin_rounds/spain_waits表示平均每次自旋所需的内部循环次数 |
| os_waits      | 表示操作系统等待的次数，当spin lock通过自旋还不能获得latch时，则进入操作系统等待状态，等待别唤醒； |
| os_yields     | 进行os_thread_yield唤醒操作的次数                            |
| os_wait_times | 操作系统等待的时间，单位是ms                                 |

### 3、InnoDB存储引擎中的锁

#### 3.1 锁的类型

InnoDB存储引擎实现了如下两种标准的行级锁：

- 共享锁（S Lock、读锁），允许事务读一行数据。
- 排它锁（X Lock、写锁）,允许事务删除或更新一行数据。

数据库中并发控制的问题的解决是由两种类型的锁实现的共享锁（也称为读锁）和排它锁（也称为写锁）；读锁是共享的，多个线程读是互不阻塞的。写锁是排它锁，写锁会阻塞其他的写锁和读锁。

一种提高共享资源并发性的方式就是让锁更具有选择性，尽量值锁定需要修改的部分数据，而不是所有资源，最理想的方式是，只对会修改的数据片进行精确锁定。任何时候，在给定的资源上，锁定的数据量越少，系统的并发程度也就越高。

由于加锁也需要消耗资源。锁的各种操作（获取、检查、释放、解除）都会增加系统的开销。锁策略就是在锁的开销和数据的安全性之间寻找平衡，这种平衡也会影响到性能。

共享锁和排它锁的兼容如下表所示：

| 锁   | X      | S      |
| ---- | ------ | ------ |
| X    | 不兼容 | 不兼容 |
| S    | 不兼容 | 兼容   |

兼容是指两个锁不相互阻塞。

InnoDB存储引擎还支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。

意向锁设计目的主要是为了在一个事务中揭示下一行将被请求的所类型。

两种意向锁：

- 意向共享锁（IS lock）,事务想要获取一张表中某几行的共享锁；
- 意向排它锁（IX lock），事务想要获取一张表中某几行的排它锁；

由于InnoDB存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞全表扫描意外的任何请求。兼容性如下所示：

| lock | IS     | IX     | S      | X      |
| ---- | ------ | ------ | ------ | ------ |
| IS   | 兼容   | 兼容   | 兼容   | 不兼容 |
| IX   | 兼容   | 兼容   | 不兼容 | 不兼容 |
| S    | 兼容   | 不兼容 | 兼容   | 不兼容 |
| X    | 不兼容 | 不兼容 | 不兼容 | 不兼容 |

#### 3.2 一致性非锁定读

一致性非锁定读是指InnoDB存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此区等待行锁的释放，而是InnoDB存储引擎会去读取行的一个快照数据。

快照数据是指改行的之前版本的数据，该实现是通过undo段实现完成，而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。读取快照数据是不需要上锁的，因为没有事务需要对历史数据进行修改操作。

非锁定读机制极大地提高了数据库的并发性，在InnoDB存储引擎的默认设置下，这时默认的读取方式，即读取不会占用和等待表上的锁。

不同事务的隔离级别下，读取的方式不同。即不是在每个事务隔离级别下都是采用非锁定的一致性读。即使使用非锁定的一致性读，但是对于快照数据的定义也各不相同。

在事务隔离级别读已提交 和 可重复读（InnoDB存储引擎 默认的事务隔离级别）下，InnoDB存储引擎使用非锁定一致性读。对于快照的定义却不同，在 读已提交 事务隔离级别下，对于快照数据总是读取被锁定行的最新一份快照数据。而在可重复读事务隔离级别下，快照数据总是读取事务开始时的行数据版本。

#### 3.3  一致性锁定读

在默认配置下，可重复读的隔离级别模式下，InnoDB存储引擎的select操作使用一致性非锁定读。但是在某些情况下需要显示的对数据库读取操作进行加锁以保证数据逻辑的一致性。InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读操作：

```mysql
SELECT ... FOR UPDATE;  		-- 加X锁
SELECT ... LOCK IN SHARE MODE;  -- 加S锁
```

注意：使用上述两句SELECT锁定语句时，必须加上BEGIN，START TRANSACTION 或 SET AUTOCOMMIT = 0；

### 4、锁的算法

#### 4.1 行锁的三种算法

InnoDB存储引擎有3种行锁的算法，其分别是：

- **Record Lock（行锁）:**锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。
- **Gap Lock（间隙锁）:**在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。
- **Next-Key Lock:**Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身；

在InnoDB存储引擎中，对于INSERT的操作，其会检查插入记录的系一条记录是否被锁定，若已经被锁定，则不允许查询。