 一、volatile关键字

1、volatile是java虚拟机提供的轻量级的同步机制：保证可见性、不保证原子性、禁止指令重排；

2、不保证原子性：会出现数据的写丢失的问题，多线程情况下出现并发数据写丢失，影响数据准确性；

3、保证原子性的方法：

- 使用synchronized关键字，强制保证原子性；
- 使用JUC下atomicInteger创建原子性变量；

4、禁止指令重排序

内存屏障：又称内存栅栏，是一个CPU指令，作用有两个：一是保证特定操作的执行顺序；二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）；

由于编译器和处理器都能执行指令重排序，如果在指令间添加一条内存屏障，则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排，也就是说通过插入内存屏障禁止在内存屏障前后的指令重排序优化。内存屏障的另一个作用就是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本；

计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为三种：

![](E:\Node\picture\163085179.jpg)

- 单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致；
- 处理器在进行重排序时必须要考虑指令之间的数据依赖性；
- 多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性时无法确定的，结果无法预测；

二、AtomicInteger原子性

1、CAS算法：compareAndSet  比较并交换；

2、Atomic类可以保证原子性，是因为底层使用CAS，全称为Compare-And-Swap是一条CPU并发原语，并发原语体现在Java语言中是就是sun.misc.Unsafe类中的各个方法，当调用这些方法时，JVM会帮我们实现CAS汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作。由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也是就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题；

3、CAS的缺点：

1.循环时间长开销很大；

2.只能保证一个共享变量的原子操作；

3.引发ABA问题；

4、ABA问题：

CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么这个时间差会导致数据的变化；例如说一个线程one从内存位置V中取出数据A，这个时候另一个线程two也从内存中去除A，并且线程two进行了一些操作后将值变成成了B，然后线程two有奖V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功；

5、ABA问题解决：

引入原子变量作为版本号，每次成功更新之后同时类型原子变量，可以使用AtomicStampedRerence类；