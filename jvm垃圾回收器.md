---
title: 垃圾回收器
date: 2021-01-16 16:37:34
tags: [垃圾回收机制]
categories: java虚拟机
---

#### 一、java堆内存的“分代”概念

在java虚拟机中，堆内存被划分新生代，老年代和持久代三部分。新生代被划分为Eden区、Survivor/S0区和Survivor/S1区。和具体划分如下：

![堆内存分代图](https://longqing9.gitee.io/blog/images/2021011801.png)

#### 二、GC的类型

***因为业界没有统一的严格意义上的界限，也没有严格意义上的GC类型***

在java虚拟机进行垃圾收集(GC)时，一般将其分为两种：次收集(Minor GC/young GC)和全收集(Full GC)。

##### 1、触发时机：

- minor gc： 虚拟机在进行minorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间,如果大于的话，直接执行minorGC。

- full gc:
  - 老年代空间不足：如果创建一个大对象，eden区中空间不足，直接保存到老年代中，当老年代空间不足时候，直接触发full gc；
  - 持久代空间不足
  - 统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间
  - 显示调用System.gc()方法
  - YGC出现promotion failure
  
  **注**：一般情况下，full GC会比minor GC慢10倍以上；

#### 三、堆内存三个区的说明

- 新生代 ：刚创建的对象，在代码运行时一般都会持续不断地创建新的对象，这些新创建的对象有很多是局部变量，很快就会变成垃圾对象。这些对象被放在一块称为新生代的内存区域。新生代的特点是垃圾对象多，存活对象少。

- 老年代 ： 一些对象很早被创建了，经历了多次GC也没有被回收，而是一直存活下来。这些对象被放在一块称为老年代的区域。老年代的特点是存活对象多，垃圾对象少。

- 永久代 ：一些伴随虚拟机生命周期永久存在的对象，比如一些静态对象，常量等。这些对象被放在一块称为永久代的区域。永久代的特点是这些对象一般不需要垃圾回收，会在虚拟机运行过程中一直存活。（在Java1.7之前，方法区中存储的是永久代对象，Java1.7方法区的永久代对象移到了堆中，而在Java1.8永久代已经从堆中移除了，这块内存给了元空间。）

  ![](https://longqing9.gitee.io/blog/images/2021011901.png)

#### 四、对象从新生代创建到老年代的历程：

##### 1、说明：

- 对于新生代区域，每次GC都会有很多垃圾对象被回收，只有少量存活。因此采用复制回收算法，GC时把剩余很少的存活对象复制过去即可；
- 在新生代区域中，并不是按照1:1的比例来进行复制回收，而是按照8:1:1的比例分为了Eden、Survivor/s0、Survivor/s1三个区域；
- Eden区对外提供堆内存，新生对象都是在Eden区被创建的；
- Survivor区则为幸存者，即经历GC后仍然存活下来的对象会被放在该区域内；
- 老年代区域对象一般存活周期较长，每次GC时，存活的对象比较多，因此采用标记-整理算法

##### 2、历程描述：

- 1、新生对象都是在Eden区被创建的；
- 2、当Eden区即将满是，则进行Minor GC(新生代GC)，把存活对象放入SurvivorA区，同时清空Eden区；
- 3、Eden区被清空后，继续对外提供堆内存；
- 4、当Eden区再次被填满，此时对Eden区和Survivor/s0区同时进行Minor GC(新生代GC)，把存活对象放入Survivor/s1区，此时同时清空Eden区和Survivor/s0区；
- 5、Eden区继续对外提供堆内存，并重复上述过程，即在 Eden 区填满后，把Eden区和某个Survivor区的存活对象放到另一个Survivor区；
- 6、当某个Survivor区被填满，且仍有对象未完全复制时，或者某些对象在反复Survive 15次左右时，则把这部分剩余对象放到老年代区域；
- 7、老年区也被填满时，进行Major GC（老年代GC），对老年代区域进行垃圾回收；
- 8、老年代区域对象一般存活周期较长，每次GC时，存活的对象比较多，GC时移动少量存活对象，不会产生内存碎片。

##### 3、触发GC的类型

Java虚拟机会把每次触发GC的信息打印出来，可以根据日志来分析触发GC的原因。

- GC_FOR_MALLOC：表示是在堆上分配对象时内存不足触发的GC；
- GC_CONCURRENT：当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存；
- GC_EXPpCIT：表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC；
- GC_BEFORE_OOM：表示是在准备抛OOM异常之前进行的最后努力而触发的GC。

#### 五、七大垃圾回收器

目前主流Java虚拟机中所采用的七种垃圾收集器： Serial、parNew、ParallelScavenge、SerialOld、ParallelOld、CMS、G1；这些垃圾收集器有些适用于新生代，有些适用于老年代，有些在新生代和老年代都适应。如下图所示，连线表示可以配合使用：

<img src="https://longqing9.gitee.io/blog/images/2021012001.png" style="zoom:80%;" />

##### 1、Serial垃圾收集器

Serial垃圾收集器是一个单线程的收集器，在进行垃圾收起时需要停止其他所有的工作线程，直到垃圾收集结束；虽然Serial垃圾收集器看似很不靠谱，但是随意限定单个CPU的场景下，这种方式简单而高效，对于200M的新生代内存空间，垃圾收集可以控制到100毫秒以内，对于用户来说基本是无感知的。Serial垃圾收集器在新生代使用的是**复制算法**。

##### 2、parNew垃圾收集器

parNew垃圾收集器是Serial垃圾收集器的多线程版，使用多线程进行垃圾收集。除此之外，和Serial垃圾收集器基本相同，parNew在多线程垃圾收集时依旧需要暂停其他所有的工作线程，直到垃圾收集结束。ParNew可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数量。parNew垃圾收集器在新生代中使用的是**复制算法**。

##### 3、Parallel Scavenge垃圾收集器

ParallelScavenge垃圾收集器也是新生代垃圾收集器，同样是多线程的垃圾收集器，和parNew不同，parallel Scavenge垃圾收集器关注的是一个可控制的吞吐量，所谓吞吐量指的是CPU用于运行代码的时间和CPU总消耗的时间比例。

**吞吐量=运行代码的时间 /（运行代码的时间+垃圾收集时间）**

理论上吞吐量越高，用户就越不能感受到停顿时间。Parallel Scavenge提供了两个参数用来控制吞吐量： **-XX:MaxGCPauseMillis**和**-XX:GCTimeRatio**。**-XX:MaxGCPauseMillis**设置内存回收花费时间最高毫秒值，但是不要一味地认为只要把值设置很小，垃圾回收就更快了。**这个停顿时间是以牺牲吞吐量和新生代空间换来的**。**XX:GCTimeRatio**表示垃圾收集时间占总时间的比例，（1~100），也就是吞吐量的倒数。默认这个值是99，就是允许最大百分之1的垃圾手机时间（1/(1+99)）。Parallel Scavenge垃圾收集器采用的是**复制算法**。

##### 4、Serial old垃圾收集器

Serial old垃圾收集器是Serial垃圾收集器的老年代的版本，是单线程的垃圾收集器，采用**标记-整理算法**，其余的和新生代的Serial基本相同。

##### 5、Parallel Old垃圾收集器

Parallel old垃圾收集器是parallel Scavenge垃圾收集器的老年代的版本，是多线程的垃圾收集器，采用的是**标记-整理算法**，也是吞吐量优先。

##### 6、CMS垃圾收集器

CMS垃圾收集器是一种以获取最短回收停顿时间为目标的收集器。CMS是基于**标记-清楚算法**的老年代垃圾收集器。CMS是目前应用最广泛的老年代垃圾收集器，他进行垃圾收集的氛围一下四步：

- 初始标记：标记GC Roots可以直接关联的对象，速度很快；
- 并发标记：根搜索算法过程；
- 重新标记：为了修正并发标记期间，因程序运行导致标记产生变动的对象；
- 并发清除：清楚垃圾。

这个过程中耗时最长的是并发标记和并发清除的过程，但是并不会暂定其他工作线程，而初始标识和重新标记的速度都很快，即使暂停也不会占用太多时间。它的优点是：**并发收集、并发清除、低停顿**。

缺点也很明显：

- **对CPU资源十分敏感**，因为并发标记和并发清除都是和程序同时运行，因此会占用CPU导致应用程序变慢。
- **无法处理浮动垃圾**，浮动垃圾就是在并发清除过程中新生成的垃圾，这部分垃圾CMS无法在本次被清理，可能出现Concurrent Mode Failed报错，因此需要预留一定的内存空间，无法等到老年代快被占满时再清除。默认情况下，CMS在老年代使用了68%后就会被激活。可以设置-XX:CMSInitiatingOccupancyFraction设置这个值。
- **产生空间碎片**，由于采用的是标记-清除算法，那就无法避免会产生空间碎片的问题，这会给分配大对象带来困难。

##### 7、G1垃圾收集器

- G1的堆结构：是把一整块内存区域划分为多个固定大小的块，JVM一般把堆划分为2000个region，然后每个region从1M到32M不等。

- 内存的分配：所有的region会被划分为Eden、Survivor、Old和Humongous，其中对Eden、Survivor和Old的理解用其他垃圾回收器去理解，这里多了一种类型Humongous，这个类型主要用来存储比标准块大百分之50或者更大的对象。

- G1中的Young GC：第一次进行Young GC时，Eden块中存活的对象会被转移到一个或多个survivor块中，存活时间达到阈值，这些对象就会被晋升到老年代中，年轻代GC通过多线程并行进行；此时会有一次 stop the world暂停，会计算出 Eden大小和 survivor 大小，用于下次young GC。统计信息会被保存下来，用于辅助计算size。比如暂停时间之类的指标也会纳入考虑。一旦发生一次新生代回收，整个新生代都会被回收（根据对暂停时间的预测值，新生代的大小可能会动态改变）；
- G1中老年代垃圾收集：老年代的垃圾回收不会收集全部的老年代空间，只会选择一部分收益最高的Region ,回收时一般会把待回收的老年代Region和所有的新生代Region放在一起进行回收，这个过程一般被称为Mixed GC;

G1中老年代垃圾收集和CMS收集器很相似：

- 1、初始化标记：附加在正常的Young GC过程中，标记所有的的根；（Stop the world）
- 2、扫描根区域：扫描Survivor Region中指向老年代的被初始化标记的引用及引用对象，这个阶段是并发执行的，但是在年轻代GC发生之前必须完成；（stop the world）
- 3、并发标记：在整个堆中查找或者的元素，此阶段可以被GC打断；
- 4、再次标记：类似CMS的重新标记，处理并发标记阶段产生的新的对象引用，这个阶段使用的是标记算法，该算法比CMS中所采用的的开很多；（stop the world）
- 5、清理阶段：G1 GC 会识别完全空闲的区域和可供进行混合垃圾回收的区域进行清理。（stop the world）

有四个阶段都需要stop the world，为了降低stop the world的时间，G1使用了RSet(Remembered Set)来记录不同代之间的引用关系。

RSet记录了以下两种引用：

- 1、老年代 Region 间的引用；

- 2、老年代 Region 到新生代 Region 的引用，Young GC 时直接将这种引用加入 GC Roots。

RSet的工作原理：

进行 Young GC 时，选择新生代所在的 Region 作为 GC Roots，这些 Region 中的 RSet 记录了老年代->新生代的的跨代引用（「谁引用了我」），**从而可以避免了扫描整个老年代**。进行 Mixed GC 时，「老年代->老年代」之间的引用，可以通过待回收 Region 中的 RSet 记录获得，「新生代->老年代」之间的引用通过扫描全部的新生代获得（前面提到过 Mixed GC 会搭 Young GC 的便车），也不需要扫描全部老年代。**总之，引入 RSet 后，GC 的堆扫描范围大大减少了。**