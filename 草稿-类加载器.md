### 1、类加载器

类加载器功能：就是通过一个类的全限定名来获取该类的二进制字节流。

#### 1.1 类加载器分类

从java虚拟机的角度来看，只存在两种不同的类加载器：

- 启动类加载器：是由C++实现的，是虚拟机自身的一部分；
- 其他所有的类加载器：是由Java语言实现的，独立存在于虚拟机外部，并且全部都继承抽象类java.lang.ClassLoader.

从开发者的角度来看，可将类加载器分为三种：

- 启动类加载器：负责加载存放在<JAVA_HOME>\lib目录或被-Xbootclasspath参数所指定的路径中存放的，且是Java虚拟机能够识别的（按照文件名识别，如rt.java、tool.jar，名字不符合的类库不会被加载）类库加载到 虚拟机的内存中。启动类加载器无法被java程序直接引用。
- 扩展类加载器：是在类sum.misc.Launcher$ExtClassLoader中以java代码的形式实现的，他负责加载<java-home>\lib\ext目录中，或被java.ext.dirs系统变量所指定的路径中的所有类库。该类加载器是由java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。
- 应用程序类加载器：是由um.misc.Launcher$ExtClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSysytemClassLoader()方法的返回值，所以有时候也别成为系统类加载器。它负责加载用户类路径上所有的类库，开发者可以再代码中使用这个类加载器。如果应用程序总没有自定义过自己的类加载器，一般情况下就是程序中默认的类加载器。

#### 1.2 类加载器的“双亲委派模型”



双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的 加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请 求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

