---
title: Synchronized原理
date: 2021-05-25 10:11:51
tags: [java,锁机制]
categories: java
---

synchronized关键字用来保证在同一时刻只有一个线程可以执行被它修饰的变量或者代码块。在JDK1.6进行了优化，减少synchronize锁对CPU的占用；

### 1、Synchronized的使用

Synchronized的常用的有三种方式：

- 作用在类的方法上： 调用该方法的this对象；
- 在类的属性变量上：  当前对象的class字节码对象；
- 在代码块中使用： 指定锁对象；

### 2、Synchronized的特性

- 原子性：指一个操作或多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么都不执行；
- 可见性：多线程访问一个资源的状态、值信息等对于其他线程都是可见的。
- 有序性：程序执行的顺序按照代码先后顺序执行。
- 可重入性：当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源,不会被阻塞。

### 3、Synchronized实现原理

在JDK 1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题，优化主要为锁的升级：偏向锁->轻量锁->重量锁：

#### 3.1 锁信息在对象中的存储

每个对象在内存中的存储分为三部分：对象头、实例数据、对齐填充；
Synchronized的锁信息主要存储在对象头的Mark work中；而对象头中包含的数据信息：Mark work、Class Metadata（类型指针）、长度（为数组时有值）；其中Markword的存储了对象自身运行的数据，HashCode、GC、分代年龄、锁状态标志、线程持有的锁、偏向的线程ID，时间戳，内存占用等；

![](https://longqing9.github.io/images/Synchronized.png)

#### 3.2 锁的升级过程

##### 偏向锁的获取过程

​	1、判断是否为可偏向状态；
​	2、如果为可偏向状态，则判断线程ID是为当前线程的id，如果是则进入同步块；
​	3、如果线程ID不是当前线程的id，则利用CAS操作竞争锁，如果竞争成功，则将Mark Word中线程id更新为当前线程ID，进入同步块；
​	4、如果竞争失败，等待全局安全点，准备撤销偏向锁，根据线程是否处于活跃状态，决定是转换为无锁状态还是升级为轻量锁。
当对象第一次被线程获取时，虚拟机会将对象头中的标志设置为01（偏向模式），同时使用CAS操作将当前线程ID记录在对象的Mark word中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机第一可以不再进行任何同步操作；
​	偏向锁的释放\升级：
​	偏向锁使用了竞争才释放的机制。偏向锁的撤销需要等待全局安全点，然后会首先暂停拥有偏向锁的线程，然后判断线程是否存活，如果还存活则升级为轻量锁，否则设置为无锁状态。

##### 轻量锁：
在代码进入同步块的时候，如果此对象没有被锁定（锁标志位为“01”状态），虚拟机首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）。然后虚拟机使用CAS操作尝试将对象的Mark Word更新为指向锁记录（Lock Record）的指针。如果更新成功，那么这个线程就拥有了该对象的锁，并且对象的Mark Word标志位转变为“00”，即表示此对象处于轻量级锁定状态；如果更新失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块中执行，否则说明这个锁对象已经被其他线程占有了。如果有两条以上的线程竞争同一个锁，那轻量级锁不再有效，要膨胀为重量级锁，锁标志变为“10”，Mark Word中存储的就是指向重量级锁的指针，而后面等待的线程也要进入阻塞状态。

##### 重量锁：

也就是平时说的Synchronized的对象锁，锁的标识为为10，其中指针指向的是monitor对象（也称为监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的。

ObjectMonitor中有两个队列，WaitSet 和 EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程。

- 当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合；
- 当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1；
- 若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。
- 若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。

如下图：

![](https://longqing9.github.io/images/20170604114223462.png)

Synchronized优化之后，锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。

参考：[深入理解Java并发之synchronized实现原理](https://blog.csdn.net/javazejian/article/details/72828483?locationNum=5&fps=1)

